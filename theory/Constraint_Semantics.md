# Constraint Semantics & Trust Model

## 1. Core Shift: From "Correct-by-Construction" to "Formally Verifiable Search"

In the early designs of Evolver, we utilized the term "Correct-by-Construction." To pursue absolute mathematical rigor, we have now refined this to "Formally Verifiable Search."

Evolver does not promise that a "solution will definitely be found." Instead, it promises that "if a solution is found, it must strictly adhere to the laws of physics, and this conclusion can be verified by a third party at a low cost."

We divide the system's trust boundaries into three levels:

| Level | Attribute | Responsible Party | Guarantee |
| :--- | :--- | :--- | :--- |
| **L0** | Algebraic Soundness | Soul (Class Group) | **Internal Consistency.** The system state $S$ is always a valid element of the Ideal Class Group $Cl(\Delta)$. It is mathematically impossible for the perturbation mechanism to produce a non-group element. |
| **L1** | Logical Validity | Body (Energy Audit) | **Projection Consistency.** The mapped logic sequence $\Pi(S)$ is checked by the STP Kernel. Contradictions (e.g., Syntax Errors, Logical Fallacies) are detected here and penalized with $E > 0$. Note: A valid L0 state can project to an invalid L1 logic; the Optimizer's job is to align them. |
| **L2** | Verifiability | Tracer | **Path Integrity.** Given initial state $x_0$ and action sequence $u_{0:k}$, anyone can replicate the evolution path to verify the claimed Energy. |

---

## 2. Level 0: Algebraic Soundness (The Hard Constraint)

The L0 guarantee is strictly limited to the Algebraic State Space.

* **The Law:** $S_{t+1} = S_t \circ \epsilon$.
* **The Guarantee:** If $S_t \in Cl(\Delta)$ and $\epsilon \in Cl(\Delta)$, then $S_{t+1} \in Cl(\Delta)$ by the closure property of the group.
* **Boundary:** L0 does not guarantee that the associated logical statement is "True". It only guarantees that the "Searcher" is walking on solid mathematical ground, not floating in undefined memory space.

---

## 3. Level 1: Logical Validity (The Soft Constraint via Energy)

While L0 ensures the walker is safe, L1 ensures the message is meaningful.

The STP Bridge acts as the Gatekeeper. It consumes the raw ProofActions generated by the Body's projection.

$$E(S) = \text{STP\_Check}(\text{Adapter}(\text{Project}(S)))$$

**Violation Handling:** If the generated logic violates STP constraints (e.g., `Assert(0 == 1)`), the system does not crash (L0 is safe). Instead, it returns a high energy penalty ($E=100.0$), forcing the Will to steer away from this algebraic region.

---

## 4. Level 2: Search Verifiability (The Proof)

The system output is a Proof of Will (Search Proof), containing:

1.  Initial state $x_0$ (Derived from Context Hash)
2.  Sequence of perturbations (actions) $\mathcal{U} = \{u_0, u_1, \dots, u_k\}$
3.  Claimed final energy $E_{claim}$

### Verification Protocol

The Verifier performs a deterministic Replay:

```rust
fn verify(proof: Proof) -> bool {
    let mut x = proof.initial_state;
    // 1. Replay Algebraic Path (L0 Check)
    for u in proof.action_sequence {
        x = x.compose(u); 
    }
    // 2. Audit Logic Energy (L1 Check)
    let logic = project(x);
    return calculate_energy(logic) == proof.claimed_energy;
}
```

This asymmetric computational cost (extremely expensive to search, extremely cheap to verify) is the core value of the Evolver architecture.

---

## Conclusion

Evolver separates Existence (Algebra, L0) from Meaning (Logic, L1).

* **Soul** ensures we exist validly.
* **Body** checks if we speak truthfully.
* **Will** struggles to align existence with truth.
