# HYPER-TENSOR PROTOCOL (HTP): Technical Specification

"Time is Evolution, Space is Projection."

## 1. Mathematical Preliminaries

### 1.1 Class Group Parameters

**Discriminant Generation:**
Define 
$$\Delta = -M$$
where $M$ is a prime number derived from the generator's context hash, satisfying:
$$M \equiv 3 \pmod 4$$
This ensures that the imaginary quadratic field $\mathbb{Q}(\sqrt{\Delta})$ possesses a non-trivial class group structure.

**Security:** The system's security relies on the computational hardness of determining the class number 
$$h(\Delta)$$
(Time Security).

### 1.2 Dual-Operator System (Algebraic Core)

HTP utilizes two distinct algebraic operators to decouple temporal causality from spatial topology.

**Time Operator ($\oplus_{\text{time}}$):** A non-commutative affine evolution operator acting on the ideal class group.
$$\mathcal{A}_1 \oplus_{\text{time}} \mathcal{A}_2 = (S_1 \circ S_2^2 \circ \epsilon_2)$$
* $S^2$ (Squaring) represents the irreversible flow of time (entropy increase).
* $\epsilon$ represents the controlled perturbation exerted by the Will (VAPO).

**Space Operator ($\otimes_{\text{space}}$):** A commutative aggregation operator used for topological projection.
$$\mathcal{A}_1 \otimes_{\text{space}} \mathcal{A}_2 = \text{Hash}(S_1) \oplus \text{Hash}(S_2) \pmod P$$
This is effectively an Artin-like Projection process, mapping group elements onto the finite field $\mathbb{Z}_P$.

---

## 2. Affine Evolution & Optimization (The Soul & Will)

### 2.1 The Algebraic State (Soul)

The state $S \in Cl(\Delta)$ is defined as an element in the ideal class group, represented by a binary quadratic form $(a, b, c)$:
$$f(x, y) = ax^2 + bxy + cy^2$$

### 2.2 Time Evolution (The Will's Loop)

Implemented in `src/will/optimizer.rs`.

* **Input:** Initial seed state $S_0$.
* **Perturbation:** Infinitesimal group elements $\epsilon \in Cl(\Delta)$ generated by the VAPO algorithm.
* **Dynamics:** $$S_{next} = S_{curr} \circ \epsilon$$
* **Result:** A final state $S^*$ optimized via energy minimization.

### 2.3 Materialization (The Body's Projection)

Implemented in `src/body/decoder.rs`.

* **Input:** The optimized state $S^*$.
* **Process:** Recursive application of the Space Operator for projection.
* **Output:** A sequence of logical action IDs (Digits) 
    $$d_1, d_2, \dots, d_k \in \mathbb{Z}_P$$

---

## 3. Hyper-Tensor Topology (v-PuNN)

### 3.1 Coordinate Mapping

Define a mapping $\Phi$ from the algebraic state $S$ to a logical path $\mathcal{P}$:
$$\Phi(S) = [ \pi_1(S), \pi_2(S^2), \pi_3(S^4), \dots ]$$
where $\pi_k$ is a projection function modulo $P_k$. This constructs a fractal decision tree.

### 3.2 Dimensional Folding

To verify logical consistency, the generated path is folded into a sequence of STP matrix operations:
$$\text{State}_{logical} = M_{d_k} \ltimes \dots \ltimes M_{d_1} \ltimes \text{State}_{init}$$

### 3.3 Orthogonal Anchoring

The HTP protocol requires that generated logic must be consistent across "orthogonal" directions:

* **Primary Path:** The directly generated chain of logical inference.
* **Dual Path:** A verification chain generated via a dual network (or by commuting the projection order).

If 
$$E(\text{Primary}) == 0$$
and 
$$E(\text{Dual}) == 0$$
the logic is considered a "Holographic Truth."

---

## 4. Protocol Flow & Verifiable Binding

### 4.1 The Proof Bundle

Under the new architecture, the `ProofBundle` contains the complete algebraic trajectory of the generation process:
$$\text{ProofBundle} := \{ \mathbf{Hash}_{ctx}, S_{final}, \text{Trace}_{\epsilon}, \mathcal{P}_{logic} \}$$
* $\mathbf{Hash}_{ctx}$: Binding to Input (Context Hash)
* $S_{final}$: The Optimized Soul (Result)
* $\text{Trace}_{\epsilon}$: The VAPO Search Path (Proof of Work)
* $\mathcal{P}_{logic}$: The Materialized Logic Path

### 4.2 Verification Algorithm (Deterministic Replay)

The logic for the Verifier:

1.  **Context Check:** Compute $h = \text{Hash}(Context)$ and verify it matches the hash in the bundle.
2.  **Evolution Replay:** Starting from $S_0 = \text{Identity}(h)$, apply the perturbations in $\text{Trace}_{\epsilon}$ sequentially to verify if $S_{final}$ is reached. This proves $S_{final}$ was derived through computation, not forgery.
3.  **Projection Check:** Run $\Phi(S_{final})$ to verify the generation of $\mathcal{P}_{logic}$.
4.  **Energy Check:** Execute the STP engine to verify 
    $$E(\mathcal{P}_{logic}) == 0$$

---

## 5. Security Assumptions

### 5.1 The Hidden Order Assumption

We assume an attacker cannot directly construct a forged state $S_{fake}$ satisfying 
$$E(\Phi(S_{fake})) == 0$$
without performing a VAPO search. This relies on the one-way nature and chaos of the $\Phi$ (projection) and STP energy functions. The landscape of logical energy is rugged; no simple inverse function exists to map $E=0$ back to $S$.

### 5.2 Time Security

Historical immutability is guaranteed by the group operation properties of the class group. Once $S_t$ is published, it is impossible to find an $S'_{t-1}$ such that 
$$S_t = S'_{t-1} \circ \epsilon$$
without having actually undergone that specific evolutionary process.

---

## 6. Conclusion

The HTP v1.2 specification defines a generative logical protocol:
1. Logic is the product of algebraic evolution.
2. Proof is the record of the evolutionary trajectory.
3. Verification is the replay of the evolutionary process.
